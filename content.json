{"meta":{"title":"jackBlog","subtitle":null,"description":"f2e开发者","author":"Tuuuuuuuuu","url":"http://yoursite.com"},"pages":[{"title":"jackTu","date":"2019-01-17T08:36:03.148Z","updated":"2019-01-17T08:36:03.148Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"javaScript设计模式之工厂模式","slug":"factory","date":"2019-03-07T03:15:35.000Z","updated":"2019-03-07T03:47:04.026Z","comments":true,"path":"2019/03/07/factory/","link":"","permalink":"http://yoursite.com/2019/03/07/factory/","excerpt":"","text":"简单工厂模式 1.1 简单工厂模式 简单工厂模式又叫静态工厂模式，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象； 12345678910111213141516171819202122232425262728function UserFactory(role) &#123; function SuperAdmin() &#123; this.name = &apos;超级管理员&apos;; this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;, &apos;应用数据&apos;, &apos;权限管理&apos;] &#125; function Admin() &#123; this.name = &apos;管理员&apos;; this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;, &apos;应用数据&apos;] &#125; function NormalUser() &#123; this.name = &apos;普通用户&apos;; this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;] &#125; switch (role) &#123; case &apos;superAdmin&apos;: return new SuperAdmin(); break; case &apos;Admin&apos;: return new Admin(); break; case &apos;NormalUser&apos;: return new NormalUser(); break; default: throw new Error(&apos;参数错误，可选参数为：superAdmin、admin、user&apos;) &#125;&#125; 优化后 1234567891011121314151617181920function UserFactory(role) &#123; function User(opt) &#123; this.name = opt.name; this.viewPage = opt.viewPage; &#125; switch (role) &#123; case &apos;superAdmin&apos;: return new User(&#123;name:&apos;超级管理员&apos;, viewPage:[&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;, &apos;应用数据&apos;, &apos;权限管理&apos;]&#125;); break; case &apos;Admin&apos;: return new User(&#123;name:&apos;管理员&apos;, viewPage:[&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;, &apos;应用数据&apos;]&#125;); break; case &apos;NormalUser&apos;: return new User(&#123;name:&apos;普通用户&apos;, viewPage:[&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;]&#125;); break; default: throw new Error(&apos;参数错误，可选参数为：superAdmin、admin、user&apos;) &#125;&#125; 工厂方法模式 1.2 工厂方法模式 工厂方法模式的本意是将实际创建对象的工作推迟到子类中，这样核心类就变成了抽象类。但是在JavaScript中很难像传统面向对象那样去实现创建抽象类。所以在JavaScript中我们只需要参考它的核心思想即可。我们可以将工厂方法看作是一个实例化对象的工厂类。 在简单工厂模式中，我们每添加一个构造函数需要修改两处代码。现在我们使用工厂方法模式改造上面的代码，刚才提到，工厂方法我们只把它看作是一个实例化对象的工厂，它只做实例化对象这一件事情！ 我们采用安全模式创建对象 1234567891011121314151617181920212223242526272829303132 // 安全模式下创建的工厂方法函数 let UserFactory = function(role) &#123; if (this intanceof UserFactory) &#123; var s = new this[role]; return s; &#125; else &#123; return new UserFactory(role); &#125; &#125; // 工厂方法函数的原型中设置所有对象的构造函数 UserFactory.protoType = &#123; function SuperAdmin() &#123; this.name = &apos;超级管理员&apos;; this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;, &apos;应用数据&apos;, &apos;权限管理&apos;] &#125; function Admin() &#123; this.name = &apos;管理员&apos;; this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;, &apos;应用数据&apos;] &#125; function NormalUser() &#123; this.name = &apos;普通用户&apos;; this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;] &#125; &#125;// 调用let superAdmin = UserFactory(&apos;SuperAdmin&apos;);let admin = UserFactory(&apos;Admin&apos;)let normalUser = UserFactory(&apos;NormalUser&apos;) 抽象工厂模式 1.3 抽象工厂模式 上面介绍了简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建。 上面例子中的superAdmin，admin，user三种用户角色，其中user可能是使用不同的社交媒体账户进行注册的，例如：wechat，qq，weibo。那么这三类社交媒体账户就是对应的类簇。在抽象工厂中，类簇一般用父类定义，并在父类中定义一些抽象方法，再通过抽象工厂让子类继承父类。所以，抽象工厂其实是实现子类继承父类的方法。 上面提到的抽象方法是指声明但不能使用的方法。在其他传统面向对象的语言中常用abstract进行声明，但是在JavaScript中，abstract是属于保留字，但是我们可以通过在类的方法中抛出错误来模拟抽象类。 下面我们分别来实现账号管理的抽象工厂方法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344let AccountAbstractFactory = function(subType, superType)&#123; // 判断抽象工厂中是否具有改抽象类 if (typeof AccountAbstractFactory[superType] === &apos;function&apos;) &#123; // 缓存类 function F()&#123;&#125;; F.protoType = new AccountAbstractFactory[superType](); // 将子类的constractor指向子类 subType.construtor = subType; // 子类继承父类 subType.protoType = new F(); &#125; else &#123; throw new Error(&apos;抽象类不存在！&apos;) &#125;&#125;// 微信用户抽象类AccountAbstractFactory.weChatUser = function()&#123; this.type = &apos;weChat&apos;;&#125;AccountAbstractFactory.weChatUser.protoType = function()&#123; getName: function()&#123; return new Error(&apos;抽象方法不能调用&apos;) &#125;&#125;// qq用户抽象类AccountAbstractFactory.QqUser = function() &#123; this.type = &apos;qq&apos;;&#125;AccountAbstractFactory.QqUser.prototype = &#123; getName: function() &#123; return new Error(&apos;抽象方法不能调用&apos;); &#125;&#125;//新浪微博用户抽象类AccountAbstractFactory.WeiboUser = function() &#123; this.type = &apos;weibo&apos;;&#125;AccountAbstractFactory.WeiboUser.prototype = &#123; getName: function() &#123; return new Error(&apos;抽象方法不能调用&apos;); &#125;&#125; 下面我们来定义普通用户的子类: 1234567891011121314151617181920212223242526272829303132333435// 普通微信用户子类function UserOfWechat(name) &#123; this.name = name; this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;]&#125;// 抽象工厂实现WechatUser类的继承AccountAbstractFactory(UserOfWechat, &apos;WechatUser&apos;);// 子类中重写抽象方法UserOfWechat.prototype.getName = function() &#123; return this.name;&#125;// 普通qq用户子类function UserOfQq(name) &#123; this.name = name; this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;]&#125;// 抽象工厂实现QqUser类的继承AccountAbstractFactory(UserOfQq, &apos;QqUser&apos;);// 子类中重写抽象方法UserOfQq.prototype.getName = function() &#123; return this.name;&#125;// 普通微博用户子类function UserOfWeibo(name) &#123; this.name = name; this.viewPage = [&apos;首页&apos;, &apos;通讯录&apos;, &apos;发现页&apos;]&#125;// 抽象工厂实现WeiboUser类的继承AccountAbstractFactory(UserOfWeibo, &apos;WeiboUser&apos;);// 子类中重写抽象方法UserOfWeibo.prototype.getName = function() &#123; return this.name;&#125; 上述代码我们分别定义了UserOfWechat，UserOfQq，UserOfWeibo三种类。这三个类作为子类通过抽象工厂方法实现继承。特别需要注意的是，调用抽象工厂方法后不要忘记重写抽象方法，否则在子类的实例中调用抽象方法会报错。我们来分别对这三种类进行实例化，检测抽象工厂方法是实现了类簇的管理。 1234567891011121314151617// 实例化微信用户let wechatUserA = new UserOfWechat(&apos;微信小李&apos;);console.log(wechatUserA.getName(), wechatUserA.type); //微信小李 wechatlet wechatUserB = new UserOfWechat(&apos;微信小王&apos;);console.log(wechatUserB.getName(), wechatUserB.type); //微信小王 wechat// 实例化qq用户let qqUserA = new UserOfQq(&apos;QQ小李&apos;);console.log(qqUserA.getName(), qqUserA.type); //QQ小李 qqlet qqUserB = new UserOfQq(&apos;QQ小王&apos;);console.log(qqUserB.getName(), qqUserB.type); //QQ小王 qq// 实例化微博用户let weiboUserA =new UserOfWeibo(&apos;微博小李&apos;);console.log(weiboUserA.getName(), weiboUserA.type); //微博小李 weibolet weiboUserB =new UserOfWeibo(&apos;微博小王&apos;);console.log(weiboUserB.getName(), weiboUserB.type); //微博小王 weibo","categories":[],"tags":[]},{"title":"创建者模式","slug":"创建者模式","date":"2019-03-07T03:02:55.000Z","updated":"2019-03-07T03:46:25.203Z","comments":true,"path":"2019/03/07/创建者模式/","link":"","permalink":"http://yoursite.com/2019/03/07/创建者模式/","excerpt":"","text":"JavaScript设计模式 之 创建者模式 创建者模式是将一个复杂对象的构建层与其表示层互相分离，同样的构建过程可采用不同的表示。 与工厂模式的区别工厂模式主要是为了创建对象实例或者类簇（抽象工厂），关心的是最终产出（创建）的是什么。不关心你的创建整个过程，仅仅需要知道你最终创建的结果。所以通过工厂模式我们得到是对象实例或者类簇。而创建者模式在创建对象时更为复杂一些，虽然其目的也是为了创建对象，但是它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节，比如创建一个人，我们创建的结果不仅仅是得到人的实例，还要关注创建人的时候，这个人穿什么衣服，男的还是女的，兴趣爱好是什么。所以说创造者莫事儿更注重的是创建的细节，而在本例中我们看到，我们需要的不仅仅是应聘者的一个实例，还要在创建过程中注意一下这位应聘者都有哪些兴趣爱好、姓名等信息。他期望的职位是什么、这些关注点都是需要我们创建的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 创建人类var Human = function(param) &#123; // 技能 this.skill = param &amp;&amp; param.skill || &apos;保密&apos; // 爱好 this.hobby = param &amp;&amp; param.hobby || &apos;保密&apos;&#125;// 人类原型方法Human.protoType = &#123; getSkill: function() &#123; return this.skill; &#125;, getHobby：function() &#123; return this.hobby; &#125;&#125;// 实例化姓名类var Named = function(name) &#123; var that = this; // 构造器 // 构造函数解析姓名的姓与名 (function()&#123; that.wholeName = name; if (name.indexOf(&apos; &apos;) &gt; -1) &#123; that.FirstName = name.slice(0, name.indexOf(&apos; &apos;)); that.secondName = name.slice(name.indexOf(&apos; &apos;)); &#125; &#125;)(name, that)&#125;// 实例化职位类var Work = function(work) &#123; var that = this; // 构造器 // 构造函数中传入的职位特征来设置相应职位以及描述 (function(work, that)&#123; switch(work)&#123; case &apos;code&apos;: that.work = &apos;工程师&apos;; that.workDescript = &apos;每天都在变成中度过&apos;; break; case &apos;UI&apos;: case &apos;UE&apos;: that.work = &apos;设计师&apos;; that.workDescipt = &apos;设计更似一种艺术&apos;; break; case &apos;teach&apos;: that.work = &apos;教师&apos;； that.workDescript = &apos;分享也是一种快乐&apos;; break; deault: that.work = work; that.workDescrip = &apos;对不起，我们还不清楚您所选择的的职位相关描述&apos;; &#125; &#125;)(work, that);&#125;// 跟换期望职位Work.protoType.changeWork = function(work) &#123; this.work = work;&#125;// 添加对职位的描述Work.protoType.changeDescript = function(setence) &#123; this.changeDescript = setence;&#125; 创建一个应聘者类 组合调用 1234567891011121314/***** 应聘者建造者* 参数 name: 姓名（全名）* 参数 work：期望职位/var Person = function(name, work)&#123; // 创建应聘者缓存对象 var _person = new Huamn(); // 创建应聘者姓名解析对象 _person.name = new Named(name); // 创建应聘者期望职位 _person.word = new Work(work); return _person;&#125; 测试 1234567var person = new Person(&apos;xiao ming&apos;, &apos;code&apos;);console.log(person.skill); // 保密console.log(person.name.FirstName); // xiaoconsole.log(person.work.work); // 工程师console.log(person.work.workDescript); // &apos;每天都在变成中度过&apos;;person.work.changeDescript(&apos;更改一下职位描述&apos;);console.log(person.work.workDescript); // 更改一下职位描述","categories":[],"tags":[]}]}